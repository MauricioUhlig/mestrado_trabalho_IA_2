# -*- coding: utf-8 -*-
"""TP2-IA - Solucao de problemas de otimizacao.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Q5oDvx7OWg_FORKEblDRjL00H_7nenJ

# Inteligência artificial
## EP2: Estudo Comparativo de Algoritmos de Otimização
## PPCOMP - IFES - Campus Serra

Professor: Sérgio Nery Simões

Aluno: Mauricio Jastrow Uhlig

Turma: 2024/2

### Descrição do Trabalho
**Contexto:** Este projeto de programação consiste em comparar o desempenho dos algoritmos de otimização aplicados a diferentes problemas. Os resultados do projeto serão (i) o código desenvolvido para cada problema e (ii) um breve relatório apresentando e discutindo os resultados comparativos. Os algoritmos a serem comparados incluem:
- **[HC-C] - Hill-Climbing (clássico);**
- **[HC-R] - Hill-Climbing with Restart;**
- **[SA] - Simulated Annealing e**
- **[GA] - Genetic Algorithm.**

**Desenvolvimento:** Os algoritmos devem ser aplicados na busca pela solução ótima de dois problemas definidos a seguir. Cada problema inclui a definição de uma função objetivo e as funções específicas para geração de vizinhos e, no caso do GA, para mutação e *crossover*. Também são definidos também os parâmetros que devem ser usados pelos métodos. Os algoritmos de otimização devem ser executados pelo menos **10 vezes**, para permitir a análise de **variabilidade** dos resultados no relatório.

1. **Problema 1: *Travelling Salesman Problem* (TSP)** - Resolver o problema do caixeiro-viajante, otimizando o trajeto.
2. **Problema 2: Minimização da Função de Rastrigin** - Minimizar uma função matemática complexa frequentemente usada em benchmarks de otimização.

Para ajudá-los a começar o desenvolvimento e prover um ambiente para testes dos algoritmos, foram fornecidos os seguintes códigos:

- (a) Implementação do algoritmo *Hill-climbing* (clássico) aplicado ao TSP, junto a funções para geração de gráficos comparativos.
- (b) Funções base do Algoritmo Genético (GA), desenvolvidas para o problema das 8-rainhas.

A partir dos ambientes (a) e (b), os algoritmos deverão ser adaptados de acordo com as especificações de cada problema, fornecida mais a frente. Os algoritmos principais devem ser implementados de forma **modular**, com alterações específicas concentradas em funções dedicadas a cada problema.

É importante ressaltar que **é proibido** utilizar bibliotecas que implementem diretamente os algoritmos de otimização. No entanto, bibliotecas auxiliares para manipulação de **estruturas de dados** são permitidas. A implementação desses algoritmos e sua aplicação em problemas reais são úteis em entrevistas técnicas
para empresas de grande porte, representando um investimento valioso na sua carreira profissional.

---------------------------------------------------------------------
"""

from TSP import TSP

from HillClimbing import HillClimbing
from HillClimbingWithRestart import HillClimbingWithRestart
from SimulatedAnnealing import SimulatedAnnealing 
from GeneticAlgorithm import GeneticAlgorithm
from Rastrigin import Rastrigin
import plots
import executor


"""### Rastrigin"""

"""## Execução

### Executa 1 vez
"""

# Simula a criação de N cidades
# com suas respectivas distâncias


import pandas as pd
url_coordenadas_cidade = 'https://www.math.uwaterloo.ca/tsp/world/wi29.tsp'

df_coordenadas = pd.read_table(
                    url_coordenadas_cidade,
                    skiprows=7,           # ignora as 7 primeiras linhas com informações
                    names=['X', 'Y'],     # nomes das colunas
                    sep=' ',              # separador das colunas
                    index_col=0,          # usar col=0 como index (nome das cidades)
                    skipfooter=1,         # ignora a última linha (EOF)
                    engine='python'       # para o parser usar skipfooter sem warning
              )

# df_coordenadas.to_csv('df_coordenadas.csv', index=False)

NUMERO_EXECUCOES = 5

# df_coordenadas = pd.read_csv('df_coordenadas.csv') Existe um bug de começar no indice errado

problema = TSP(df_coordenadas)

algoritmos = [
    # HillClimbing(problema),
    #HillClimbingWithRestart(problema, n_execucoes=100),
    SimulatedAnnealing(problema, n_iter=1000, n_rep=50, initial_temperature=1, cooling_rate=0.0011111),
    # GeneticAlgorithm(problema, tamanho_populacao = 100, n_geracoes = 1000, taxa_mutacao = 0.1)
    ]

df_custos_tsp, solucao = executor.executa_n_vezes(algoritmos, n_vezes=NUMERO_EXECUCOES)
df_solucao_tsp = pd.DataFrame(solucao,columns=["Algoritmo", "Custo", "Solucao"]).set_index("Algoritmo")
df_custos_tsp.to_csv('df_custos_tsp.csv')
df_solucao_tsp.to_csv('df_solucao_tsp.csv')

# print(df_custos_tsp.T.describe())

problema = Rastrigin()
algoritmos = [
    # HillClimbing(problema),
    # HillClimbingWithRestart(problema, n_execucoes=1000),
    # SimulatedAnnealing(problema, n_iter=1000, n_rep=50, initial_temperature=1, cooling_rate=0.0011111),
    # GeneticAlgorithm(problema, tamanho_populacao = 100, n_geracoes = 1000, taxa_mutacao = 0.1)
    ]

df_custos_rastrigin, solucao = executor.executa_n_vezes(algoritmos, n_vezes=NUMERO_EXECUCOES)
df_solucao_rastrigin = pd.DataFrame(solucao,columns=["Algoritmo", "Custo", "Solucao"]).set_index("Algoritmo")
df_custos_rastrigin.to_csv('df_custos_rastrigin.csv')
df_solucao_rastrigin.to_csv('df_solucao_rastrigin.csv')

# print(df_custos_rastrigin.T.describe())

# print('\n\n\n')
# df_custos_import = pd.read_csv('df_custos_rastrigin.csv', index_col=0)
# print(df_custos_import.T.describe())

# print(f'\nCusto aleatório: {tsp.calcula_custo(tsp.solucao):7.3f}')
# plots.plota_rotas(tsp.coordenadas, tsp.solucao)

# tsp.reset()
# hc = HillClimbing(tsp)
# melhor_custo, melhor_solucao = hc.run()
# print(f'\ncusto hill climb classic: {melhor_custo:7.3f} Rota: {melhor_solucao}')
# #plots.plota_rotas(tsp.coordenadas, melhor_solucao, "hill climb classic", melhor_custo)

# tsp.reset()
# hcwr = HillClimbingWithRestart(tsp, 100)
# melhor_custo, melhor_solucao = hcwr.run()
# print(f'\ncusto hill climb with restart: {melhor_custo:7.3f} Rota: {melhor_solucao}')
# #plots.plota_rotas(tsp.coordenadas, melhor_solucao, "hill climb with restart", melhor_custo)

# tsp.reset()
# sa = SimulatedAnnealing(tsp, 1400, 20, 100, 0.997)
# melhor_custo, melhor_solucao = sa.run()
# print(f'\ncusto Simulated Annealing: {melhor_custo:7.3f} Rota: {melhor_solucao}')
# #plots.plota_rotas(tsp.coordenadas, melhor_solucao, "Simulated Annealing", melhor_custo)

# ga = GeneticAlgorithm(tsp, tamanho_populacao = 100, n_geracoes = 1000, taxa_mutacao = 0.1)
# melhor_custo, melhor_solucao = ga.run()
# print(f'\ncusto Genetic Algorithm: {melhor_custo:7.3f} Rota: {melhor_solucao}')
# #plots.plota_rotas(tsp.coordenadas, melhor_solucao, "Genetic Algorithm", melhor_custo)

# rstng = Rastrigin()
# hc = HillClimbing(rstng)
# melhor_custo, melhor_solucao = hc.run()
# print(f'\ncusto hill climb classic: {melhor_custo:7.3f} Ponto: {melhor_solucao}')

# rstng.reset()
# hcwr = HillClimbingWithRestart(rstng, 100)
# melhor_custo, melhor_solucao = hcwr.run()
# print(f'\ncusto hill climb with restart: {melhor_custo:7.3f} Ponto: {melhor_solucao}')
# #plots.plota_rotas(tsp.coordenadas, melhor_solucao, "hill climb with restart", melhor_custo)

# rstng.reset()
# sa = SimulatedAnnealing(rstng, 1000, 50, 1, 0.0011111)
# melhor_custo, melhor_solucao = sa.run()
# print(f'\ncusto Simulated Annealing: {melhor_custo:7.3f} Ponto: {melhor_solucao}')
# #plots.plota_rotas(tsp.coordenadas, melhor_solucao, "Simulated Annealing", melhor_custo)

# ga = GeneticAlgorithm(rstng, tamanho_populacao = 100, n_geracoes = 1000, taxa_mutacao = 0.1)
# melhor_custo, melhor_solucao = ga.run()
# print(f'\ncusto Genetic Algorithm: {melhor_custo:7.3f} Ponto: {melhor_solucao}')
# #plots.plota_rotas(tsp.coordenadas, melhor_solucao, "Genetic Algorithm", melhor_custo)
