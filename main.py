# -*- coding: utf-8 -*-
"""TP2-IA - Solucao de problemas de otimizacao.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Q5oDvx7OWg_FORKEblDRjL00H_7nenJ

# Inteligência artificial
## EP2: Estudo Comparativo de Algoritmos de Otimização
## PPCOMP - IFES - Campus Serra

Professor: Sérgio Nery Simões

Aluno: Mauricio Jastrow Uhlig

Turma: 2024/2

### Descrição do Trabalho
**Contexto:** Este projeto de programação consiste em comparar o desempenho dos algoritmos de otimização aplicados a diferentes problemas. Os resultados do projeto serão (i) o código desenvolvido para cada problema e (ii) um breve relatório apresentando e discutindo os resultados comparativos. Os algoritmos a serem comparados incluem:
- **[HC-C] - Hill-Climbing (clássico);**
- **[HC-R] - Hill-Climbing with Restart;**
- **[SA] - Simulated Annealing e**
- **[GA] - Genetic Algorithm.**

**Desenvolvimento:** Os algoritmos devem ser aplicados na busca pela solução ótima de dois problemas definidos a seguir. Cada problema inclui a definição de uma função objetivo e as funções específicas para geração de vizinhos e, no caso do GA, para mutação e *crossover*. Também são definidos também os parâmetros que devem ser usados pelos métodos. Os algoritmos de otimização devem ser executados pelo menos **10 vezes**, para permitir a análise de **variabilidade** dos resultados no relatório.

1. **Problema 1: *Travelling Salesman Problem* (TSP)** - Resolver o problema do caixeiro-viajante, otimizando o trajeto.
2. **Problema 2: Minimização da Função de Rastrigin** - Minimizar uma função matemática complexa frequentemente usada em benchmarks de otimização.

Para ajudá-los a começar o desenvolvimento e prover um ambiente para testes dos algoritmos, foram fornecidos os seguintes códigos:

- (a) Implementação do algoritmo *Hill-climbing* (clássico) aplicado ao TSP, junto a funções para geração de gráficos comparativos.
- (b) Funções base do Algoritmo Genético (GA), desenvolvidas para o problema das 8-rainhas.

A partir dos ambientes (a) e (b), os algoritmos deverão ser adaptados de acordo com as especificações de cada problema, fornecida mais a frente. Os algoritmos principais devem ser implementados de forma **modular**, com alterações específicas concentradas em funções dedicadas a cada problema.

É importante ressaltar que **é proibido** utilizar bibliotecas que implementem diretamente os algoritmos de otimização. No entanto, bibliotecas auxiliares para manipulação de **estruturas de dados** são permitidas. A implementação desses algoritmos e sua aplicação em problemas reais são úteis em entrevistas técnicas
para empresas de grande porte, representando um investimento valioso na sua carreira profissional.

---------------------------------------------------------------------
"""

from TSP import TSP

from HillClimbing import HillClimbing
from HillClimbingWithRestart import HillClimbingWithRestart
from SimulatedAnnealing import SimulatedAnnealing 
from GeneticAlgorithm import GeneticAlgorithm
from Rastrigin import Rastrigin
import plots
import executor


"""### Rastrigin"""

"""## Execução

### Executa 1 vez
"""

# Simula a criação de N cidades
# com suas respectivas distâncias


import pandas as pd
url_coordenadas_cidade = 'https://www.math.uwaterloo.ca/tsp/world/wi29.tsp'

df_coordenadas = pd.read_table(
                    url_coordenadas_cidade,
                    skiprows=7,           # ignora as 7 primeiras linhas com informações
                    names=['X', 'Y'],     # nomes das colunas
                    sep=' ',              # separador das colunas
                    index_col=0,          # usar col=0 como index (nome das cidades)
                    skipfooter=1,         # ignora a última linha (EOF)
                    engine='python'       # para o parser usar skipfooter sem warning
              )

# df_coordenadas.to_csv('df_coordenadas.csv', index=False)

NUMERO_EXECUCOES = 30
plot = True

# df_coordenadas = pd.read_csv('df_coordenadas.csv') Existe um bug de começar no indice errado

def calculate_coolig_rate(n_iter, initial_tem, percent_when_zero):
    return initial_tem/(n_iter * percent_when_zero)

problema = TSP(df_coordenadas)
sa_n_iter = 7000
sa_n_rep = 70
sa_temp = 1
sa_cooling_rate = calculate_coolig_rate(sa_n_iter,sa_temp, 0.9)
algoritmos = [
    HillClimbing(problema),
    HillClimbingWithRestart(problema, n_execucoes=50),
    SimulatedAnnealing(problema, n_iter=sa_n_iter, n_rep=sa_n_rep, initial_temperature=sa_temp, cooling_rate=sa_cooling_rate),
    GeneticAlgorithm(problema, tamanho_populacao = 110, n_geracoes = 800, taxa_mutacao = 0.1)
    ]

df_custos_tsp, solucao, df_hit_func_objetivo_tsp, df_tempo_tsp = executor.executa_n_vezes(algoritmos, n_vezes=NUMERO_EXECUCOES, plot=plot)
df_solucao_tsp = pd.DataFrame(solucao,columns=["Algoritmo", "Custo", "Solucao"]).set_index("Algoritmo")
df_custos_tsp.to_csv('df_custos_tsp.csv')
df_solucao_tsp.to_csv('df_solucao_tsp.csv')
df_hit_func_objetivo_tsp.to_csv('df_hit_func_objetivo_tsp.csv')
df_tempo_tsp.to_csv('df_tempo_tsp.csv')

# # print(df_custos_tsp.T.describe())

sa_n_iter = 110
sa_n_rep = 10
sa_temp = 1
sa_cooling_rate = calculate_coolig_rate(sa_n_iter,sa_temp, 0.9)
problema = Rastrigin()
algoritmos = [
     HillClimbing(problema),
     HillClimbingWithRestart(problema, n_execucoes=450),
     SimulatedAnnealing(problema, n_iter=sa_n_iter, n_rep=sa_n_rep, initial_temperature=sa_temp, cooling_rate=sa_cooling_rate),
     GeneticAlgorithm(problema, tamanho_populacao = 20, n_geracoes = 50, taxa_mutacao = 0.1)
    ]

df_custos_rastrigin, solucao, df_hit_func_objetivo_rastrigin, df_tempo_rastrigin = executor.executa_n_vezes(algoritmos, n_vezes=NUMERO_EXECUCOES, plot=plot)
df_solucao_rastrigin = pd.DataFrame(solucao,columns=["Algoritmo", "Custo", "Solucao"]).set_index("Algoritmo")
df_custos_rastrigin.to_csv('df_custos_rastrigin.csv')
df_solucao_rastrigin.to_csv('df_solucao_rastrigin.csv')
df_hit_func_objetivo_rastrigin.to_csv('df_hit_func_objetivo_rastrigin.csv')
df_tempo_rastrigin.to_csv('df_tempo_rastrigin.csv')
